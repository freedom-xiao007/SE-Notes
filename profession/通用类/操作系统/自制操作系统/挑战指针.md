# 自制操作系统日记（5）：挑战指针
***

使用wirte_mem8时的编译nasm代码：

```c
void write_mem8(int addr, int data);
void start(void) {
    int i;
    for (i = 0xa0000; i < 0xaffff; i++) {
	write_mem8(i, i & 0x0f);
    }
}
```

```nasm
ALIGN   8
?_001:  mov     eax, ebx                                ; 0018 _ 89. D8
        mov     dword [esp], ebx                        ; 001A _ 89. 1C 24
        add     ebx, 1                                  ; 001D _ 83. C3, 01
        and     eax, 0FH                                ; 0020 _ 83. E0, 0F
        mov     dword [esp+4H], eax                     ; 0023 _ 89. 44 24, 04
        call    _write_mem8                             ; 0027 _ E8, 00000000(rel)
        cmp     ebx, 720895                             ; 002C _ 81. FB, 000AFFFF
        jnz     ?_001                                   ; 0032 _ 75, E4

_write_mem8:     ; void write_mem8(int addr, int data);
        MOV      ECX, [ESP+4]      ; [ESP + 4]中存放的是地址，将其读入ECX
        MOV      AL, [ESP+8]       ; [ESP + 8]中存放的是数据，将其读入AL
        MOV      [ECX], AL
        RET
```

使用char*时的编译nasm代码：

```c
void start(void) {
    int i;
    char *p;
    for (i = 0xa0000; i < 0xaffff; i++) {
	p = (char *) i;
	*p = i & 0x0f;
    }

    /* 或者下面这样写，生成的汇编码也一样 */
    char *p;
    p = (char *) 0xa0000; /*将地址赋值进去*/
    for (i = 0; i <= 0xffff; i++) {
    	p[i] = i & 0x0f;
    }
}
```

```nasm
?_001:  mov     edx, eax                                ; 0018 _ 89. C2
        add     eax, 1                                  ; 001A _ 83. C0, 01
        and     edx, 0FH                                ; 001D _ 83. E2, 0F
        mov     byte [eax-1H], dl                       ; 0020 _ 88. 50, FF
        cmp     eax, 720895                             ; 0023 _ 3D, 000AFFFF
        jnz     ?_001                                   ; 0028 _ 75, EE
```

** 没有看到int相关的代用，为啥会变颜色？

显示模式设置

遇到的坑点

fill循环问题？y距离问题?