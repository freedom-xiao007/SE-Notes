# 并发综述

---

## 综述

-   三个核心问题：
    -   分工：合理的规划、拆解任务
    -   同步：任务之间有依赖
    -   互斥：程序数据的正确性，注意死锁

### 场景

-   CPU、内存、磁盘 I/O 等，三者之间速度差异较大

    -   CPU 增加缓存，均衡与内存的速度差异
    -   操作系统增加进程、线程，分时复用 CPU，均衡 CPU 与 I/O 的差异
    -   编译程序优化指令执行顺序，使缓存更加合理的应用

-   可见性：一个线程对共享变量的修改，另一个线程能立即看到；多核多缓存导致不可见性
-   原子性：一个或多个操作在 CPU 执行过程中不被终端的特性；CPU 时间切片带来的不可预期
-   有序性：程序命令的顺序执行；编译优化有可能打乱顺序

-   可见性、有序性的解决：
    -   volatile:禁用CPU缓存，保证变量的可见性
    -   synchronized
    -   final
    -   Happens-Before
        - 1.程序的顺序性：程序代码执行顺序
        - 2.volatile变量规则：变量写先与读
        - 3.传递性：A先B，B先C，则A先C
        - 4.管程锁定规则：解锁后序与加锁
        - 5.线程启动规则：start先与子线程后续操作
        - 6.线程终止规则：子线程中的操作先于join
-   原子性的解决：锁，注意锁的设计，锁与被包含资源之间的对应关系

-   synchronized：管程，但无法解决死锁；需改进能够响应中断、支持超时、非阻塞获取锁；支持多个条件变量
-   lock 和 condition：可重入锁，能够响应中断、支持超时、非阻塞获取锁；支持多个条件变量
-   Semaphore:同一个锁计数
-   ReadWriteLock：读写锁，读多写少；小心读锁升级写锁的写法
-   StampedLock：写锁、悲观锁、乐观锁；不支持重入
-   CountDownLatch 主要用来解决一个线程等待多个线程的场景
-   CyclicBarrier 是一组线程之间互相等待

-   原子类：CAS，ABA 版本

对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。
