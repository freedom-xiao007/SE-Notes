# 缓存相关概览
***
## 缓存相关理论
缓存是提升系统性能的一个简单有效的办法

缓存的由来和使用场景
本地缓存 --> 远程缓存：缓存中间件
读多写少

缓存的性能示例

缓存加载时机
1、启动全量加载 ==> 全局有效，使用简单
2、懒加载
同步使用加载 ==>
- 先看缓存是否有数据，没有的话从数据库读取
- 读取的数据，先放到内存，然后返回给调用方
延迟异步加载 ==>
- 从缓存获取数据，不管是否为空直接返回 ==>
- 策略1异步）如果为空，则发起一个异步加载的线程，负责加载数据
- 策略2解耦）异步线程负责维护缓存的数据，定期或根据条件触发更新

缓存的有效性与数据同步

缓存使用不当导致的问题
1、系统预热导致启动慢
试想一下，一个系统启动需要预热半个小时。
导致系统不能做到快速应对故障宕机等问题。
2、系统内存资源耗尽
只加入数据，不能清理旧数据。
旧数据处理不及时，或者不能有效识别无用数据。

容量
资源有限
- 缓存数据容量是必须要考虑的问题
- 思考系统的设计容量、使用容量、峰值，应该是我们做架构设计的一个常识

过期策略
- 按FIFO或LRU
- 按固定时间过期
- 按业务时间加权：例如3+5x

缓存穿透
问题：大量并发查询不存在的KEY，导致都直接将压力透传到数据库。
分析：为什么会多次透传呢？不存在一直为空。
需要注意让缓存能够区分KEY不存在和查询到一个空值。
解决办法：
1、缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY。
2、Bloom过滤或RoaringBitmap 判断KEY是否存在。
3、完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。

缓存击穿
问题：某个KEY失效的时候，正好有大量并发请求访问这个KEY。
分析：跟前面一个其实很像，属于比较偶然的。
解决办法：
1、KEY的更新操作添加全局互斥锁。
2、完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。

缓存雪崩
问题：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数
据库压力过大升值宕机。
分析：一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存数据同
一个时间点大规模不可用，或者都更新。所以，需要我们的更新策略要在时间上合适，数据要均
匀分散，缓存服务器要多台高可用。
解决办法：
1、更新策略在时间上做到比较均匀。
2、使用的热数据尽量分散到不同的机器上。
3、多台机器做主从复制或者多副本，实现高可用。
4、实现熔断限流机制，对系统进行负载能力控制。

## 缓存相关组件
### Redis
相关基础结构
相关高级机构及应用场景

Redis相关原理

单机 --> 集群高可用

Redis 使用场景 -1. 业务数据缓存 * *
经典用法。
1、通用数据缓存，string，int，list，map等。
2、实时热数据，最新500条数据。
3、会话缓存，token缓存等。

Redis 使用场景 -2. 业务数据处理
1、非严格一致性要求的数据：评论，点击等。
2、业务数据去重：订单处理的幂等校验等。
3、业务数据排序：排名，排行榜等。

Redis 使用场景 -3. 全局一致计数 * *
1、全局流控计数
2、秒杀的库存计算
3、抢红包
4、全局ID生成

Redis 使用场景 -4. 高效统计计数
1、id去重，记录访问ip等全局bitmap操作
2、UV、PV等访问量==>非严格一致性要求

Redis 使用场景 -5. 发布订阅与 Stream
1、Pub-Sub 模拟队列
subscribe comments
publish comments java
2、Redis Stream 是 Redis 5.0 版本新增加的数据结构。
Redis Stream 主要用于消息队列（MQ，Message Queue）。
具体可以参考 https://www.runoob.com/redis/redis-stream.html

Redis 使用场景 -6. 分布式锁 * *
1、获取锁--单个原子性操作
SET dlock my_random_value NX PX 30000
2、释放锁--lua脚本-保证原子性+单线程，从而具有事务性
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
关键点：原子性、互斥、超时


Redis 的 Java 客户端 -Jedis
官方客户端，类似于JDBC，可以看做是对redis命令的包装。
基于BIO，线程不安全，需要配置连接池管理连接。

Redis 的 Java 客户端 -Lettuce
目前主流推荐的驱动，基于Netty NIO，API线程安全。

Redis 的 Java 客户端 -Redission
基于Netty NIO，API线程安全。
亮点：大量丰富的分布式功能特性，比如JUC的线程安全集合和工具的分布式版本，分
布式的基本数据类型和锁等。


Redis 性能优化
- 核心优化点：
1、内存优化
https://redis.io/topics/memory-optimization
hash-max-ziplist-value 64
zset-max-ziplist-value 64
2、CPU优化
不要阻塞
谨慎使用范围操作
SLOWLOG get 10 默认10毫秒，默认只保留最后的128条


Redis 使用的一些经验
1、性能：
1) 线程数与连接数；
2) 监控系统读写比和缓存命中率；
2、容量：
1) 做好容量评估，合理使用缓存资源；
3、资源管理和分配：
1) 尽量每个业务集群单独使用自己的Redis，不混用；
2) 控制Redis资源的申请与使用，规范环境和Key的管理（以一线互联网为例）；
3) 监控CPU 100%，优化高延迟的操作。


高可用
Redis 主从复制：从单机到多节点 ~ mysql 主从
Redis Sentinel 主从切换：走向高可用
Redis Cluster ：走向分片 ~ 全自动分库分表
Redis 的 Java 分布式组件库


### 内存网格 - Hazelcast
Hazelcast IMGD(in-memory data grid) 是一个标准的内存网格系统；它具有以下的一
些基本特性：
1. 分布式的：数据按照某种策略尽可能均匀的分布在集群的所有节点上。
2. 高可用：集群的每个节点都是 active 模式，可以提供业务查询和数据修改事务；部
分节点不可用，集群依然可以提供业务服务。
3. 可扩展的：能按照业务需求增加或者减少服务节点。
4. 面向对象的：数据模型是面向对象和非关系型的。在 java 语言应用程序中引入
hazelcast client api是相当简单的。
5. 低延迟：基于内存的，可以使用堆外内存。
文档：https://docs.hazelcast.org/docs/4.1.1/manual/html-single/index.html

内存网格 - Hazelcast 数据分区
内存网格 - Hazelcast 集群与高可用
内存网格 - Hazelcast 事务支持
内存网格 - Hazelcast 数据亲密性
内存网格 - Hazelcast 控制台