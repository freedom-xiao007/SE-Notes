# STL 空间配置器
***
*参考：《STL源码剖析》--第二章：空间配置器*

### 一、 new 和 delete
&ensp;&ensp;&ensp;&ensp;在我们平时的程序使用中对一个对象的new和delete包含两阶操作：new是先调用：：operator new 配置内存，然后调用对象构造函数构造对象内容；delete是先调用对象析构函数，然后调用：：operator delete 释放内存

##### 疑问？
- 1.那在对基本内置类型调用new和delete的情况是怎么样的？

### 二、STL 空间配置器的 空间分配
&ensp;&ensp;&ensp;&ensp;与平时new和delete不同的是在STL中将new和delete的两个阶段的操作分开了，让其功能更加专一，分为内存分配和对象构造部分。在STL的配置器文件<memory>中包含了三个基本的配置文件：

- 1.<stl_construct.h>:定义全局的construct和destroy，负责对象的构造和析构
- 2.<stl_alloc.h>:定义了一、二级配置器，彼此合作，为对象配置空间
- 3.<stl_uninitialized.h>：定义了一些复制、填充大块内存数据的全局函数

#### 1.构造和析构
- 构造：在源码的construct构造函数中接受一个指针P和初值value，使用C++的placement new运算子将初值设定指针所指的空间上
- 析构：在源码的destroy析构函数中可以接受一个析构对象和一定范围内的多个析构对象,但在析构多个对象的时候需要确定是否有不要析构对象，如果没有必要析构对象，那就不必一个一个的调用对象的析构函数，因为调用析构函数也是需要时间和资源的。如果有必要析构对象，那就一个一个地调用析构函数

##### 疑问？
- 1.C++的placement运算子具体是什么？
- 2.什么情况下对象的析构函数是没有必要的，无关痛痒的？

#### 2.内存配置
&ensp;&ensp;&ensp;&ensp;在内存空间配置中分有两级配置，一级配置器负责128bytes的内存分配，而二级分配负责小于等于128bytes的。

- 1.第一级配置器：在第一级配置器中有分配、释放、重置内存操作，但其中调用的不是C++的：：operate new之类的操作，而是C的malloc、free等操作，一个原因可能是兼容性的问题，另一个原因的C++没有重置空间的操作。
- 2.第二季配置器：在其中考虑到空间碎片问题，使用链表（内存池）来处理小的内存分配，在其中的内存池链表好像用了一个比较厉害的编程技巧······链表好像是16个吧
- 3.内存分配：在内存分配中如果需要的内存大小大于128bytes则调用第一级配置器，反之调用第二级配置器，检查第二级配置器的free list，如果有合适的就分配给它，没有合适的就上调的八的倍数在寻找分配，如此循环下去
- 4.内存回收：同内存分配一样，分大小在一二级配置器中回收内存
- 5.赋值、填充函数：赋值填充函数将分配内存和赋值分开类，先有足够的内存空间，再给空间赋值

